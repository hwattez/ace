package problems.todo;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;

import org.xcsp.common.IVar;
import org.xcsp.common.IVar.Var;
import org.xcsp.common.predicates.XNodeParent;
import org.xcsp.modeler.api.ProblemAPI;
import org.xcsp.modeler.entities.CtrEntities.CtrAlone;
import org.xcsp.modeler.implementation.NotData;

import constraints.hard.extension.structures.SmartTuple;
import constraints.hard.global.SeqBin;
import problem.Problem;
import problems.ReaderFile.ReaderTxt;
import utility.Kit;
import variables.VariableInteger;

// java abscon.Resolution problems.real.SportsBreaks sports12Sol.txt 2 -ev -f=cop -s=2
public class SportsBreaks implements ProblemAPI, ReaderTxt {

	int nTeams, nWeeks;
	int[][][] schedule; // schedule specified in the file

	void data() {
		// you must Enter the name of a file containing a solution of the sports scheduling problem (as generated by SportsDual)
		int p = 0;
		while (hasNextLine()) {
			String[] toks = nextLine().split("\\s+");
			if (nTeams == 0) {
				nWeeks = toks.length;
				nTeams = toks.length + 1;
				schedule = new int[nTeams / 2][nWeeks][];
			}
			for (int w = 0; w < nWeeks; w++)
				schedule[p][w] = new int[] { Integer.parseInt(toks[w].split("vs")[0]), Integer.parseInt(toks[w].split("vs")[1]) };
			p++;
		}
		Kit.control(p == nTeams / 2);
	}

	@NotData
	Var[] wo;
	@NotData
	Var[][] mo;
	@NotData
	Var[][] h;
	@NotData
	Var[] b;

	int periodOf(int w, int t) {
		return IntStream.range(0, nTeams / 2).filter(i -> schedule[i][w][0] == t || schedule[i][w][1] == t).findFirst().orElse(-1);
	}

	boolean homeOf(int w, int t) {
		return schedule[IntStream.range(0, nTeams / 2).filter(i -> schedule[i][w][0] == t || schedule[i][w][1] == t).findFirst().orElse(-1)][w][0] == t;
	}

	SmartTuple buildSmartTupleFor(Var[] scpKeeps, int t, int w, int weekNewPosition) {
		List<XNodeParent<? extends IVar>> list = new ArrayList<>();
		IntStream.range(0, nWeeks).forEach(i -> list.add(i == weekNewPosition ? eq(wo[i], w) : ne(wo[i], w)));
		list.add(homeOf(weekNewPosition, t) ? eq(scpKeeps[weekNewPosition], h[t][w]) : ne(scpKeeps[weekNewPosition], h[t][w]));
		return new SmartTuple(list);
	}

	CtrAlone buildSmart(int t, int w) {
		Var[] scpKeeps = variablesFrom(range(nWeeks), wi -> mo[periodOf(wi, t)][wi]);
		SmartTuple[] smartTuples = range(nWeeks).mapToObj(wi -> buildSmartTupleFor(scpKeeps, t, w, wi));
		return ((Problem) imp()).smart(vars(wo, scpKeeps, h[t][w]), smartTuples);
	}

	@Override
	public void model() {
		wo = array("wo", size(nWeeks), dom(range(nWeeks)), "Weeks Order: wo[w] is the position of the week w of the initial schedule after reordering");
		mo = array("mo", size(nTeams / 2, nWeeks), dom(0, 1),
				"Keep Matchs Order: mo[p][w] is true iff we keep the order (home/away) of the match on period p and week w before reordering");
		h = array("h", size(nTeams, nWeeks), dom(0, 1), "h[t][w] is true iff team t plays at home on week w after reordering");
		b = array("b", size(nTeams), dom(rangeClosed(1, nWeeks)), "b[t] counts the number of breaks for team t in the solution");

		allDifferent(wo);
		forall(range(nTeams).range(nWeeks), (t, w) -> buildSmart(t, w));
		forall(range(nTeams), t -> ((Problem) imp()).addCtr(new SeqBin(((Problem) imp()), (VariableInteger) b[t], (VariableInteger[]) h[t], EQ, null)));
		// cardinality(b, new int[] { 1, 2 }, new int[] { 2, nTeams - 2 });

		equal(mo[0][0], 0); // Symmetry breaking: one match order is assigned
		intension(le(wo[0], nWeeks / 2 + 1)); // Symmetry breaking: original week 0 is in the first half

		minimize(SUM, b);
	}

	int[][][] newSchedule;

	// @Override
	// public void prettyDisplay() {
	// newSchedule = newSchedule != null ? newSchedule : new int[nPeriods][nWeeks][2];
	// for (int p = 0; p < nPeriods; p++)
	// for (int w = 0; w < nWeeks; w++) {
	// int[] match = newSchedule[p][((Variable) wo[w]).dom.uniqueValue()];
	// match[0] = schedule[p][w][((Variable) mo[p][w]).dom.uniqueValue() == 1 ? 0 : 1];
	// match[1] = schedule[p][w][((Variable) mo[p][w]).dom.uniqueValue() == 1 ? 1 : 0];
	// }
	// Kit.log.config(Kit.join(newSchedule, "\n", "\t", "vs") + "\n");
	// }
}